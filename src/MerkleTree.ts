import { sha256Hash, SHA256_HASH_LENGTH } from './Encoding';

export type Hash = Uint8Array
export type MerkleProof = Hash[]

export class MerkleTree<T> {
  private proofs: Hash[][] = []
  private values: T[] = []

  constructor (public encoder: (a: T, includeType?: boolean) => Uint8Array, values: T[] = []) {
    this.append(...values)
  }

  public async getRoot(): Promise<Hash> {
    return this.proofs[this.proofs.length - 1][0]
  }

  public async length(): Promise<number> {
    return this.values.length
  }

  public async getValues(): Promise<T[]> {
    return this.values
  }

  public async get(index: number): Promise<[value: T, proof: MerkleProof] | undefined> {
    const proofs: Uint8Array[] = []
    let layer = 0

    if (index < 0 || (index >= this.values.length && this.proofs.length > 0)) {
      return
    }

    let i = index

    while(i > 0) {
      proofs.push(this.proofs[layer][i ^ 1] ?? new Uint8Array())
      layer = layer + 1
      i = i >> 1
    }

    return [this.values[index], proofs]
  }

  public async getLast(count: number): Promise<[values: T[], proofs: MerkleProof] | undefined> {
    const len = await this.length()
    return this.getRange(len - count - 1, len - 1)
  }

  public async getRange(start: number, end: number): Promise<[values: T[], proofs: MerkleProof] | undefined> {
    if (start < 0 || end < 0 || start > this.values.length || end > this.values.length || start > end) {
      return
    }

    const values = this.values.slice(start, end)

    // The proof is generated by taking the full proof tree, and then triming all entries in range
    // and then trimming nodes where both children are known. After all known nodes are removed,
    // all necessary entries are added on each layer.

    // TODO: generate the proof value

    return [values, []]
  }

  public async getByHash(hash: Uint8Array): Promise<[value: T, proof: MerkleProof] | undefined> {
    const index = this.proofs[0].findIndex(value => value.every((x, i) => x == hash[i]))
    return this.get(index)
  }

  public async append(...values: T[]): Promise<number> {
    values.forEach(value => {
      this.values.push(value)
      const encodedValue = this.encoder(value, true)
      if (this.proofs.length == 0) {
        this.proofs.push([])
        return this.proofs[0].push(sha256Hash(encodedValue))
      } else {
        const length = this.proofs[0].push(sha256Hash(encodedValue))

        let layer = 0
        let index = length - 1
        while (index) {
          const pair = new Uint8Array(2 * SHA256_HASH_LENGTH)
          pair.set(this.proofs[layer][index & ~1], 0)
          pair.set(this.proofs[layer]?.[index | 1] ?? new Uint8Array(), SHA256_HASH_LENGTH)

          index = index >> 1
          layer++
          if (layer >= this.proofs.length) {
            this.proofs.push([])
          }
          this.proofs[layer][index] = sha256Hash(pair)
        }
      }
    })

    return this.values.length
  }

  public static validate(root: Uint8Array, index: number, entry: Uint8Array, proof: Uint8Array[]): boolean {
    let accum = sha256Hash(entry)

    for (let count = 0; count < proof.length; count++) {
      const nextPair = new Uint8Array(2 * SHA256_HASH_LENGTH)
      if (index & 1) {
        nextPair.set(proof[count], 0)
        nextPair.set(accum, SHA256_HASH_LENGTH)
      } else {
        nextPair.set(accum, 0)
        nextPair.set(proof[count], SHA256_HASH_LENGTH)
      }
      
      accum = sha256Hash(nextPair)
    }

    return root.every((x, i) => x == accum[i])
  }
}

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MerkleTree = void 0;
const Encoding_1 = require("./Encoding");
class MerkleTree {
    constructor(encoder, values = []) {
        this.encoder = encoder;
        this.proofs = [];
        this.values = [];
        this.append(...values);
    }
    getRoot() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.proofs[this.proofs.length - 1][0];
        });
    }
    length() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.values.length;
        });
    }
    getValues() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.values;
        });
    }
    get(index) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const proofs = [];
            let layer = 0;
            if (index < 0 || (index >= this.values.length && this.proofs.length > 0)) {
                return;
            }
            let i = index;
            while (i > 0) {
                proofs.push((_a = this.proofs[layer][i ^ 1]) !== null && _a !== void 0 ? _a : new Uint8Array());
                layer = layer + 1;
                i = i >> 1;
            }
            return [this.values[index], proofs];
        });
    }
    getLast(count) {
        return __awaiter(this, void 0, void 0, function* () {
            const len = yield this.length();
            return this.getRange(len - count - 1, len - 1);
        });
    }
    getRange(start, end) {
        return __awaiter(this, void 0, void 0, function* () {
            if (start < 0 || end < 0 || start > this.values.length || end > this.values.length || start > end) {
                return;
            }
            const values = this.values.slice(start, end);
            // The proof is generated by taking the full proof tree, and then triming all entries in range
            // and then trimming nodes where both children are known. After all known nodes are removed,
            // all necessary entries are added on each layer.
            // TODO: generate the proof value
            return [values, []];
        });
    }
    getByHash(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            const index = this.proofs[0].findIndex(value => value.every((x, i) => x == hash[i]));
            return this.get(index);
        });
    }
    append(...values) {
        return __awaiter(this, void 0, void 0, function* () {
            values.forEach(value => {
                var _a, _b;
                this.values.push(value);
                const encodedValue = this.encoder(value, true);
                if (this.proofs.length == 0) {
                    this.proofs.push([]);
                    return this.proofs[0].push((0, Encoding_1.sha256Hash)(encodedValue));
                }
                else {
                    const length = this.proofs[0].push((0, Encoding_1.sha256Hash)(encodedValue));
                    let layer = 0;
                    let index = length - 1;
                    while (index) {
                        const pair = new Uint8Array(2 * Encoding_1.SHA256_HASH_LENGTH);
                        pair.set(this.proofs[layer][index & ~1], 0);
                        pair.set((_b = (_a = this.proofs[layer]) === null || _a === void 0 ? void 0 : _a[index | 1]) !== null && _b !== void 0 ? _b : new Uint8Array(), Encoding_1.SHA256_HASH_LENGTH);
                        index = index >> 1;
                        layer++;
                        if (layer >= this.proofs.length) {
                            this.proofs.push([]);
                        }
                        this.proofs[layer][index] = (0, Encoding_1.sha256Hash)(pair);
                    }
                }
            });
            return this.values.length;
        });
    }
    static validate(root, index, entry, proof) {
        let accum = (0, Encoding_1.sha256Hash)(entry);
        for (let count = 0; count < proof.length; count++) {
            const nextPair = new Uint8Array(2 * Encoding_1.SHA256_HASH_LENGTH);
            if (index & 1) {
                nextPair.set(proof[count], 0);
                nextPair.set(accum, Encoding_1.SHA256_HASH_LENGTH);
            }
            else {
                nextPair.set(accum, 0);
                nextPair.set(proof[count], Encoding_1.SHA256_HASH_LENGTH);
            }
            accum = (0, Encoding_1.sha256Hash)(nextPair);
        }
        return root.every((x, i) => x == accum[i]);
    }
}
exports.MerkleTree = MerkleTree;
//# sourceMappingURL=MerkleTree.js.map
import { LogicSigAccount } from 'algosdk';
import { Deployer, SignCallback } from "./Deployer";
import { Address, Amount, AssetId, UnixTimestamp, OrderType, OrderData, SignedOrder, OpenOrder, CancelTicket, PairInfo, CancelledOrder, Match, OnChainBalance, UsersHealth, BLLookUp, OrderGroup, ConnectInfo, C3Request, Asset } from "./types";
import { TealSignCallback } from "./Order";
import { Fetch } from "./Fetch";
import { UserProxy } from './UserProxy';
export * from "./types";
export * from "./Encoding";
export * from "./Order";
export * from "./Cancel";
export * from "./Match";
export * from "./MerkleTree";
export * from "./Json";
export * from "./UserProxy";
export { Deployer, SignCallback, IStateInfo } from "./Deployer";
export { Signer } from "./Signer";
export declare function connectC3(serverURL: string, nodeURL: string, nodePort: number | string, nodeToken: string, signCallback: SignCallback, tealSignCallback: TealSignCallback): Promise<C3Sdk>;
export declare class C3Sdk {
    readonly deployer: Deployer;
    private fetch;
    private init;
    private signCallback;
    private tealSignCallback;
    constructor(deployer: Deployer, fetch: Fetch, init: ConnectInfo, signCallback: SignCallback, tealSignCallback: TealSignCallback);
    private isOptedInValues;
    createUserProxy(user: Address): Promise<UserProxy>;
    performC3Op(req: C3Request, userProxy: UserProxy): Promise<string>;
    createOrder(user: Address, type: OrderType, baseId: AssetId, quoteId: AssetId, price: number, amount: Amount, expiresOn: UnixTimestamp, createdOn: UnixTimestamp): OrderData;
    createMarketOrder(user: Address, type: OrderType, baseId: AssetId, quoteId: AssetId, amount: Amount, expiresOn: UnixTimestamp, createdOn: UnixTimestamp): OrderData;
    signOrder(order: OrderData): Promise<SignedOrder>;
    makeOrderProxy(user: Address, timestamp: UnixTimestamp): Promise<LogicSigAccount>;
    submitOrder(order: SignedOrder): Promise<SignedOrder>;
    cancelOrder(order: SignedOrder): Promise<CancelTicket>;
    getAssets(): Promise<Asset[]>;
    getPairs(): Promise<PairInfo[]>;
    isOptedIn(userProxy: Address): Promise<boolean>;
    getUserOrders(user: Address): Promise<OpenOrder[]>;
    getGroupedOrders(tokenA: AssetId, tokenB: AssetId, count: number): Promise<OrderGroup>;
    getUserCancelledOrders(user: Address): Promise<CancelledOrder[]>;
    getLatestMatches(count: number): Promise<Match[]>;
    getUserMatches(user: Address): Promise<Match[]>;
    getOnChainOrder(proxy: Address): Promise<any>;
    getOnChainBalance(user: Address): Promise<OnChainBalance>;
    lookupLendingPool(user: Address, assetId: AssetId): Promise<BLLookUp>;
    getUserHealth(user: Address): Promise<UsersHealth>;
}
